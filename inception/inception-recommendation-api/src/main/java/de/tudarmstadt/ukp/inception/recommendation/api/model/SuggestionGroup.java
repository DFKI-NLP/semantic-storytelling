/*
 * Copyright 2018
 * Ubiquitous Knowledge Processing (UKP) Lab
 * Technische Universit√§t Darmstadt
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.tudarmstadt.ukp.inception.recommendation.api.model;

import static java.util.Arrays.asList;
import static java.util.Collections.emptyMap;
import static java.util.Collections.singletonMap;
import static java.util.Collections.sort;
import static java.util.Collections.unmodifiableList;
import static java.util.Collections.unmodifiableMap;
import static java.util.Comparator.comparing;
import static java.util.stream.Collectors.groupingBy;
import static java.util.stream.Collectors.toList;
import static org.apache.commons.collections4.IteratorUtils.unmodifiableIterator;

import java.io.Serializable;
import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Stream;

import org.apache.commons.lang3.Validate;
import org.apache.commons.lang3.builder.CompareToBuilder;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;

/**
 * Group of alternative suggestions generated by one or more recommenders. The group maintains an
 * order of the alternative suggestions, by default using the confidence score.
 */
public class SuggestionGroup
    extends AbstractCollection<AnnotationSuggestion>
    implements Serializable
{
    private static final long serialVersionUID = 8729617486073480240L;
    
    private final List<AnnotationSuggestion> suggestions;
    private boolean sorted = true;
    private Offset offset;
    private String feature;
    private long layerId;
    private String documentName;

    public SuggestionGroup()
    {
        suggestions = new ArrayList<>();
    }
    
    public SuggestionGroup(AnnotationSuggestion... aItems)
    {
        suggestions = new ArrayList<>(asList(aItems));
        sorted = suggestions.size() < 2;
        if (!suggestions.isEmpty()) {
            offset = suggestions.get(0).getOffset();
            feature = get(0).getFeature();
            layerId = get(0).getLayerId();
            documentName = get(0).getDocumentName();
        }
    }

    public String getFeature()
    {
        return feature;
    }

    public long getLayerId()
    {
        return layerId;
    }

    public String getDocumentName()
    {
        return documentName;
    }
    
    public Offset getOffset()
    {
        return offset;
    }
    
    public AnnotationSuggestion get(int aIndex)
    {
        return suggestions.get(aIndex);
    }
    
    private void ensureSortedState()
    {
        // To the outside, the group should appear to be sorted.
        if (!sorted) {
            sort(suggestions, comparing(AnnotationSuggestion::getConfidence).reversed());
            sorted = true;
        }
    }
    
    @Override
    public Stream<AnnotationSuggestion> stream()
    {
        ensureSortedState();
        return suggestions.stream();
    }
    
    /**
     * Get the deltas of all candidates. The deltas are calculated separately for each recommender
     * if the group contains recommendations from multiple recommenders. That is necessary because
     * the confidence scores of different recommenders are not necessarily on the same scale.
     * Additionally, only suggestions that are {@link AnnotationSuggestion#isVisible() visible} are
     * taken into consideration.
     */
    public Map<Long, List<Delta>> getAllDeltas()
    {
        if (isEmpty()) {
            return emptyMap();
        }
        else if (size() == 1) {
            AnnotationSuggestion top = get(0);
            return singletonMap(top.getRecommenderId(), asList(new Delta(top)));
        }
        else {
            // Group the suggestions by recommender because the confidence scores cannot be compared
            // across recommenders
            Map<Long, List<AnnotationSuggestion>> suggestionsByRecommenders = stream()
                    .collect(groupingBy(AnnotationSuggestion::getRecommenderId));

            Map<Long, List<Delta>> result = new HashMap<>();
            for (Entry<Long, List<AnnotationSuggestion>> e : suggestionsByRecommenders.entrySet()) {
                long recommenderId = e.getKey();
                // We consider only candidates that are visible
                List<AnnotationSuggestion> candidates = e.getValue().stream()
                        .filter(AnnotationSuggestion::isVisible).collect(toList());
                List<Delta> deltas = new ArrayList<>();
                
                Iterator<AnnotationSuggestion> i = candidates.iterator();
                AnnotationSuggestion first = i.next();
                while (i.hasNext()) {
                    AnnotationSuggestion second = i.next();
                    deltas.add(new Delta(first, second));
                    first = second;
                }
                deltas.add(new Delta(first));
                
                result.put(recommenderId, unmodifiableList(deltas));
            }
            
            return unmodifiableMap(result);
        }
    }

    /**
     * Get the top delta per recommender. The deltas are calculated separately for each recommender
     * if the group contains recommendations from multiple recommenders. That is necessary because
     * the confidence scores of different recommenders are not necessarily on the same scale.
     * Additionally, only suggestions that are {@link AnnotationSuggestion#isVisible() visible} are
     * taken into consideration.
     */
    public Map<Long, Delta> getTopDeltas()
    {
        if (isEmpty()) {
            return emptyMap();
        }
        else if (size() == 1) {
            AnnotationSuggestion top = get(0);
            if (top.isVisible()) {
                return singletonMap(top.getRecommenderId(), new Delta(top));
            }
            else {
                return emptyMap();
            }
        }
        else {
            // Group the suggestions by recommender because the confidence scores cannot be compared
            // across recommenders - note that the grouped lists are still sorted as the
            // we ensure that all the access methods (iterator, stream, etc) only return sorted
            // data.
            Map<Long, List<AnnotationSuggestion>> predictionsByRecommenders = stream()
                    .collect(groupingBy(AnnotationSuggestion::getRecommenderId));

            Map<Long, Delta> result = new HashMap<>();
            for (Entry<Long, List<AnnotationSuggestion>> e : predictionsByRecommenders.entrySet()) {
                long recommenderId = e.getKey();
                // We consider only candidates that are visible - note that the filtered list is
                // still sorted
                List<AnnotationSuggestion> visibleSuggestions = e.getValue().stream()
                        .filter(AnnotationSuggestion::isVisible)
                        .collect(toList());
                
                if (visibleSuggestions.isEmpty()) {
                    // If a recommender has no visible suggestions, we skip it - nothing to do here
                }
                else if (visibleSuggestions.size() == 1) {
                    // If there is only one visible suggestions, grab it to create the delta
                    result.put(recommenderId, new Delta(visibleSuggestions.get(0)));
                }
                else {
                    // Exploiting the fact that the filtered suggestions are still sorted, we just
                    // grab the first and second one to construct the delta
                    result.put(recommenderId,
                            new Delta(visibleSuggestions.get(0), visibleSuggestions.get(1)));
                }
            }
            
            return unmodifiableMap(result);
        }
    }

    @Override
    public boolean add(AnnotationSuggestion aSuggestion)
    {
        boolean empty = isEmpty();
        
        // When we add the second element to the group, then it is probably no longer sorted
        if (!empty) {
            sorted = false;
        }
        
        // All suggestions in a group must come from the same document (because they must be
        // on the same position) and layer/feature
        if (!empty) {
            AnnotationSuggestion representative = get(0);
            Validate.isTrue(
                    representative.getBegin() == aSuggestion.getBegin() && 
                    representative.getEnd() == aSuggestion.getEnd(),
                    "All suggestions in a group must be at the same position: expected [%d-%d] but got [%d-%d]",
                    representative.getBegin(), representative.getEnd(), aSuggestion.getBegin(),
                    aSuggestion.getEnd());
            Validate.isTrue(representative.getDocumentName().equals(aSuggestion.getDocumentName()),
                    "All suggestions in a group must come from the same document: expected [%s] but got [%s]",
                    representative.getDocumentName(), aSuggestion.getDocumentName());
            Validate.isTrue(representative.getLayerId() == aSuggestion.getLayerId(),
                    "All suggestions in a group must be on the same layer: expected [%d] but got [%d]",
                    representative.getLayerId(), aSuggestion.getLayerId());
            Validate.isTrue(representative.getFeature().equals(aSuggestion.getFeature()),
                    "All suggestions in a group must be for the same feature: expected [%s] but got [%s]",
                    representative.getFeature(), aSuggestion.getFeature());
        }
        
        // Cache information that must be consistent in the group when the first item is added
        if (empty) {
            offset = aSuggestion.getOffset();
            feature = aSuggestion.getFeature();
            layerId = aSuggestion.getLayerId();
            documentName = aSuggestion.getDocumentName();
        }
        
        return suggestions.add(aSuggestion);
    }

    @Override
    public Iterator<AnnotationSuggestion> iterator()
    {
        ensureSortedState();
        // Avoid changes to the group via the iterator since that might interfere with our sorting
        return unmodifiableIterator(suggestions.iterator());
    }
    
    @Override
    public boolean isEmpty()
    {
        return suggestions.isEmpty();
    }

    @Override
    public int size()
    {
        return suggestions.size();
    }

    public static SuggestionGroupCollector collector()
    {
        return new SuggestionGroupCollector();
    }
    
    public static Collection<SuggestionGroup> group(Collection<AnnotationSuggestion> aSuggestions)
    {
        SortedMap<GroupKey, SuggestionGroup> grouped = aSuggestions.stream()
                .collect(groupingBy(GroupKey::new, TreeMap::new, SuggestionGroup.collector()));
        return grouped.values();
    }

    private static class GroupKey
        implements Comparable<GroupKey>
    {
        private final int begin;
        private final int end;
        private final String feature;
        private final long layerId;

        public GroupKey(AnnotationSuggestion aSuggestion)
        {
            super();
            begin = aSuggestion.getBegin();
            end = aSuggestion.getEnd();
            feature = aSuggestion.getFeature();
            layerId = aSuggestion.getLayerId();
        }

        @Override
        public boolean equals(final Object other)
        {
            if (!(other instanceof GroupKey)) {
                return false;
            }
            GroupKey castOther = (GroupKey) other;
            return new EqualsBuilder().append(begin, castOther.begin).append(end, castOther.end)
                    .append(feature, castOther.feature).append(layerId, castOther.layerId)
                    .isEquals();
        }

        @Override
        public int hashCode()
        {
            return new HashCodeBuilder().append(begin).append(end).append(feature).append(layerId)
                    .toHashCode();
        }

        @Override
        public int compareTo(final GroupKey other)
        {
            return new CompareToBuilder()
                    .append(layerId, other.layerId)
                    .append(feature, other.feature)
                    // Sort by begin increasing
                    .append(begin, other.begin)
                    // Sort by end decreasing
                    .append(other.end, end)
                    .toComparison();
        }
    }
    
    public static class Delta
        implements Serializable
    {
        private static final long serialVersionUID = -4892325166786170047L;
        
        private final double delta;
        private final AnnotationSuggestion first;
        private final AnnotationSuggestion second;

        public Delta(AnnotationSuggestion aFirst)
        {
            this(aFirst, null);
        }

        public Delta(AnnotationSuggestion aFirst, AnnotationSuggestion aSecond)
        {
            Validate.notNull(aFirst, "At least first item must be given to compute delta");

            first = aFirst;
            second = aSecond;

            if (second == null) {
                delta = Math.abs(aFirst.getConfidence());
            }
            else {
                delta = Math.abs(first.getConfidence() - second.getConfidence());
            }
        }

        public AnnotationSuggestion getFirst()
        {
            return first;
        }

        public Optional<AnnotationSuggestion> getSecond()
        {
            return Optional.ofNullable(second);
        }

        public double getDelta()
        {
            return delta;
        }
    }
    
    public static class SuggestionGroupCollector
        implements Collector<AnnotationSuggestion, SuggestionGroup, SuggestionGroup>
    {

        @Override
        public Supplier<SuggestionGroup> supplier()
        {
            return SuggestionGroup::new;
        }

        @Override
        public BiConsumer<SuggestionGroup, AnnotationSuggestion> accumulator()
        {
            return SuggestionGroup::add;
        }

        @Override
        public BinaryOperator<SuggestionGroup> combiner()
        {
            return (group1, group2) -> {
                group2.forEach(suggestion -> group1.add(suggestion));
                return group1;
            };
        }

        @Override
        public Function<SuggestionGroup, SuggestionGroup> finisher()
        {
            return Function.identity();
        }

        @Override
        public Set<Characteristics> characteristics()
        {
            return Collections.emptySet();
        }
    }
}
